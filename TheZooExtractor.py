import logging
import os
import zipfile

from malware_extractor import MalwareExtractor


logger = logging.getLogger(__name__)


class MalwareBazaarExtractor(MalwareExtractor):

    @staticmethod
    def test_zip_password(file_path, password) -> bool:
        with zipfile.ZipFile(file_path) as mal_zip:
            if len(mal_zip.filelist) == 0:
                raise Exception("Empty Zip file")
            first_file = mal_zip.filelist[0]
            try:
                mal_zip.open(first_file, pwd=password)
                return True
            except Exception:
                return False

    @staticmethod
    def copy_new_password_zip(source_dir_path, output_dir_path, filename, password):
        # extract the files from the password protected zip file, and write them to a
        # new one
        infile_name = os.path.join(source_dir_path, filename)
        outfile_name = os.path.join(output_dir_path, filename)
        with zipfile.ZipFile(infile_name) as infile, zipfile.ZipFile(outfile_name) as outfile:
            for zip_name in infile.namelist():
                extracted_file = infile.open(zip_name, pwd=password)
                outfile.writestr(zip_name, extracted_file.read())

    def handle_entry(self, dirpath, filenames):
        password_file = None
        zip_file = None
        for filename in filenames:
            if filename.endswith(".pass"):
                password_file = filename
            elif filename.endswith('.zip'):
                zip_file = filename
        if zip_file is None:
            logger.error(f"no zip file found in {dirpath}")
            return
        source_dir_path = os.path.join(self.collector_path, dirpath)
        source_zip_path = os.path.join(source_dir_path, zip_file)
        output_dir_path = os.path.join(self.extracted_path, dirpath)
        output_zip_path = os.path.join(output_dir_path, zip_file)
        if os.path.exists(output_zip_path):
            # we've done this one already, skip it
            return
        if password_file is None:
            # implies (I assume) un-passworded zip file...if it's not "infected",
            # then we
            if self.test_zip_password(source_zip_path, "infected"):
                self.copy_one_file(source_dir_path, output_dir_path, zip_file)
            else:
                logger.error(f"missing password file for {zip_file}, and 'infected' doesn't work.")
                return
        else:
            with open(password_file) as pass_file:
                password = pass_file.read().strip()
            if not password:
                # opened file, but got empty password?
                # assume "infected"
                password = "infected"
            if self.test_zip_password(source_zip_path, password):
                if password == "infected":
                    self.copy_one_file(source_dir_path, output_dir_path, zip_file)
                else:
                    self.copy_new_password_zip(source_dir_path, output_dir_path, zip_file, password)
            else:
                logger.error(f"Error reading {zip_file} with password {password}")
                return

    def process_input(self):
        # files in here are in subdirectories named for each malware family. In each malware
        # is password protected. In practice it looks like the password in each case is "infected", but
        # since they provide a password file with each malware, I don't like assuming that.
        # we should check each zipfile, and if it's *not* "infected", extract and re-compress the zipfile
        # with that password, since that's what our stoq side will be expecting.
        for (dirpath, dirnames, filenames) in os.walk(self.collector_path):
            if filenames:
                try:
                    self.handle_entry(dirpath, filenames)
                except Exception:
                    logger.exception(f"Error processing {dirpath}")


if __name__ == "__main__":
    logger.info("Malware Bazaar Extractor starting up.")
    # assume mounted path is path to directory of files, so skipping any need for sub-directories.
    collector_path = os.environ.get("COLLECTOR_PATH")
    extractor_path = os.environ.get("EXTRACTOR_PATH")
    extractor = MalwareBazaarExtractor(collector_path, extractor_path)
    extractor.process_input()
    logger.info("Malware Bazaar Extractor completed.")
